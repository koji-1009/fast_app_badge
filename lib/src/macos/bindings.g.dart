// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint, unused_import
import 'dart:ffi' as ffi;
import 'package:objective_c/objective_c.dart' as objc;
import 'package:ffi/ffi.dart' as pkg_ffi;

late final _class_NSDockTile = objc.getClass("NSDockTile");
late final _sel_isKindOfClass_ = objc.registerName("isKindOfClass:");
final _objc_msgSend_19nvye5 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_badgeLabel = objc.registerName("badgeLabel");
final _objc_msgSend_151sglz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_setBadgeLabel_ = objc.registerName("setBadgeLabel:");
final _objc_msgSend_xtuoz7 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
typedef instancetype = ffi.Pointer<objc.ObjCObjectImpl>;
typedef Dartinstancetype = objc.ObjCObject;
late final _sel_init = objc.registerName("init");
late final _sel_new = objc.registerName("new");
late final _sel_allocWithZone_ = objc.registerName("allocWithZone:");
final _objc_msgSend_1cwp428 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.NSZone>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.NSZone>,
      )
    >();
late final _sel_alloc = objc.registerName("alloc");

/// NSDockTile
extension type NSDockTile._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [NSDockTile] that points to the same underlying object as [other].
  NSDockTile.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [NSDockTile] that wraps the given raw object pointer.
  NSDockTile.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [NSDockTile].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_NSDockTile,
  );

  /// alloc
  static NSDockTile alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NSDockTile, _sel_alloc);
    return NSDockTile.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSDockTile allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NSDockTile,
      _sel_allocWithZone_,
      zone,
    );
    return NSDockTile.fromPointer($ret, retain: false, release: true);
  }

  /// new
  static NSDockTile new$() {
    final $ret = _objc_msgSend_151sglz(_class_NSDockTile, _sel_new);
    return NSDockTile.fromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of NSDockTile constructed with the default `new` method.
  NSDockTile() : this.as(new$().object$);
}

extension NSDockTile$Methods on NSDockTile {
  /// badgeLabel
  objc.NSString get badgeLabel {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_badgeLabel);
    return objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// init
  NSDockTile init() {
    objc.checkOsVersionInternal(
      'NSDockTile.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSDockTile.fromPointer($ret, retain: false, release: true);
  }

  /// setBadgeLabel:
  set badgeLabel(objc.NSString value) {
    _objc_msgSend_xtuoz7(
      object$.ref.pointer,
      _sel_setBadgeLabel_,
      value.ref.pointer,
    );
  }
}

late final _class_NSApplication = objc.getClass("NSApplication");
late final _sel_sharedApplication = objc.registerName("sharedApplication");
late final _sel_dockTile = objc.registerName("dockTile");

/// NSApplication
extension type NSApplication._(objc.ObjCObject object$)
    implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [NSApplication] that points to the same underlying object as [other].
  NSApplication.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [NSApplication] that wraps the given raw object pointer.
  NSApplication.fromPointer(
    ffi.Pointer<objc.ObjCObjectImpl> other, {
    bool retain = false,
    bool release = false,
  }) : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [NSApplication].
  static bool isA(objc.ObjCObject obj) => _objc_msgSend_19nvye5(
    obj.ref.pointer,
    _sel_isKindOfClass_,
    _class_NSApplication,
  );

  /// alloc
  static NSApplication alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NSApplication, _sel_alloc);
    return NSApplication.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSApplication allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(
      _class_NSApplication,
      _sel_allocWithZone_,
      zone,
    );
    return NSApplication.fromPointer($ret, retain: false, release: true);
  }

  /// new
  static NSApplication new$() {
    final $ret = _objc_msgSend_151sglz(_class_NSApplication, _sel_new);
    return NSApplication.fromPointer($ret, retain: false, release: true);
  }

  /// sharedApplication
  static NSApplication sharedApplication() {
    final $ret = _objc_msgSend_151sglz(
      _class_NSApplication,
      _sel_sharedApplication,
    );
    return NSApplication.fromPointer($ret, retain: true, release: true);
  }

  /// Returns a new instance of NSApplication constructed with the default `new` method.
  NSApplication() : this.as(new$().object$);
}

extension NSApplication$Methods on NSApplication {
  /// dockTile
  NSDockTile get dockTile {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_dockTile);
    return NSDockTile.fromPointer($ret, retain: true, release: true);
  }

  /// init
  NSApplication init() {
    objc.checkOsVersionInternal(
      'NSApplication.init',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(
      object$.ref.retainAndReturnPointer(),
      _sel_init,
    );
    return NSApplication.fromPointer($ret, retain: false, release: true);
  }
}
